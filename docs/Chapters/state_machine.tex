\chapter{State Machine}
\label{chap:state_machine}
The task that is going to be described throughtout this document was designed as a state machine, where the progression through the different states is driven by certain events. Figure \ref{fig:state_machine} shows the state machine that describes this task.

\begin{figure}[!ht]
    \centering
    \begin{tikzpicture}
        \matrix (m) [matrix of nodes, row sep = 2em, column sep = 2em, nodes = {text depth = 1ex, text height = 2ex, draw, circle, minimum size = 55 pt}]
        {
        ITI & Start Trial & FT & Stimulus & Choice & Reward \\
            &             &    &  Abort   &        &        \\
        };
        \draw [-stealth]
            (m-1-1) edge (m-1-2)
            (m-1-2) edge (m-1-3)
            (m-1-3) edge (m-1-4)
            (m-1-4) edge (m-1-5)
            (m-1-5) edge (m-1-6)
            (m-1-6) edge[bend right] (m-1-1)
            (m-1-2) edge["miss", sloped, font=\small] (m-2-4) 
            (m-1-3) edge["miss", sloped, font=\small] (m-2-4) 
            (m-1-4) edge["miss", sloped, font=\small] (m-2-4) 
            (m-1-5) edge["miss", sloped, font=\small] (m-2-4) 
            (m-2-4) edge[bend left] (m-1-1);
    \end{tikzpicture}
    \caption{State machine of the task}
    \label{fig:state_machine}
\end{figure}

From Figure \ref{fig:state_machine}, it is possible to see that from some states (Start Trial, FT, Stimulus, Choice) there are two states that these states can progress to. This happens because there was a need to implement a way to abort the current trial of the task in case a certain condition is not met in each of these states. The rest of the chapter consists of a brief description of what happens in each state, in which the explanation of the progression conditions is included.

\section{Inter-Trial Interval}
\label{sec:iti}
The Inter-Trial Interval (ITI) state is, as the name suggests, the time interval that separates two consecutive trials. Since there is a need to setup each trial (for example, to (re)set some parameters) and the duration of the ITI is, typically, a few seconds, this state is also used to prepare the new trial. Currently, the actions that take place in the ITI state are:
\begin{itemize}
    \item Checking if a block of trials ended in the previous trial and, if so, reset the block variables and update the block number and training level;
    \item Updating the trial number;
    \item Randomizing the ABL (average binaural level) and ILD (inter-aural level) values and selecting the sound that is going to be played in the current trial.
\end{itemize}

\section{Start Trial}
\label{sec:start_trial}
A trial starts when the rodent pokes his nose in the central nose port (CNP). So this state consists of waiting that the rodent starts poking the CNP. If there is a poke within a certain time limit (for example, 6 seconds), the task continues as it is supposed to, otherwise this trial is aborted.

\section{Fixation Time}
\label{sec:fixation_time}
This is the state that precedes the stimulus presentation. The rodent should stay in the CNP during the entire time this state lasts so that the task progresses as expected, otherwise the trial is aborted. The fixation time varies from trial to trial - it is randomly generated - in order to make the timing of the stimulus presentation (which happens as soon as the fixation time ends) unpredictable. If the stimulus presentation timing was predictable, the resultant reaction times would be affected (and biased). The fixation time is given by:
\begin{gather}
    t_{\text{Fix}} = t_{\text{Base Fix}} + (X \sim \text{Exp}(\lambda))
\end{gather}

\section{Stimulus}
\label{sec:stimulus}
This is the state where the stimulus is presented. The stimulus stops when either the rodent leaves the CNP or when the defined presentation time elapses (the presentation time is usually of a few seconds). It is possible to define a minimum reaction time. If the timed reaction time is less than the minimum required, the trial is aborted.

\section{Choice}
\label{sec:choice}
When the stimulus presentation stops, the animal has to pick the side (left or right) which corresponds to the speaker which played the sound the loudest by poking in either lateral nose port. If the animal doesn't decide within a certain time (typically, of a few seconds), the trial is aborted.

\section{Reward}
\label{sec:reward}
The Reward state evaluated wether the rodent got the answer right or not. In case the answer is wrong, a penalty time is applied (10 seconds for instance). If the answer is right, the animal only gets the reward (water) if he stayed in the correct LNP for at least a minimum amount of time.

\section{Abort}
\label{sec:abort}
As mentioned before, the Abort state is triggered when some conditions are not met in the previous states. This state consists of a small time penalty (typically about 1 second).

Since this state is one of the two possible final states of a trial, there is a need to set/update some variables that would normally be set/updated in states that the state machine did not get into during the current trial.

% Figure \ref{fig:main_workflow} shows the main workflow of the Bonsai project that implements the state machine that describes the task. Note the similarities between the state machine diagram and Figure \ref{fig:main_workflow}, where the states represented in Figure \ref{fig:state_machine} are implemented in the Bonsai workflow as SelectMany nodes.

% \begin{figure}[!ht]
%     \centering
%     \includegraphics[width=\textwidth]{Figures/full_workflow.png}
%     \caption{Main workflow}
%     \label{fig:main_workflow}
% \end{figure}
% In addition to the state machine workflow, 4 GroupWorkflow nodes are also part of the main workflow. These nodes are responsible for initializing the subjects (variables) and configuring the hardware that is going to be used throughtout the execution of the workflow.

% \subsection{Behavior}
% \label{subsec:behavior}
% This experimental setup uses a Harp Behavior board as an interface with the 3 mice pokes through the RJ input ports. Additionally, since the board reads an analog event every $\sim 1$ ms, it is possible to use the timestamps of the hardware to timestamp different experimental events.

% Therefore, this GroupWorkflow initiates the Harp Behavior board so that it is possible to send and receive messages from it throughtout the task throught the BehaviorCommands and the BehaviorMessages subjects (variables). In addition, this GroupWorkflow also initializes the Timestamp subject (variable) which sends the hardware timestamps mentioned above to the parts of the workflow that need them and initializes a subject (variable) per poke which only sends a timestamped event when the value of the corresponding poke changes from HIGH to LOW or vice-versa. 

% In order to guarantee that an event corresponding to a certain poke is sent only when its value changes, a GroupWorkflow called FilterPokeEvents is connected to the output of the Behavior.TimestampedDigitalInputState node (which is responsible for sending any digital events the board receives) and to the MulticastSubject node corresponding to a specific poke. The logic inside the FilterPokeEvents node is shown in Figure \ref{fig:filter_poke_events}.

% % From Figure \ref{fig:behavior_node}, it is possible to note that the Behavior.TimestampedDigitalInputState node is connected to 3 TimestampPoke nodes. These GroupWorkflow nodes guarantee that an event for each poke is only sent to the subject (variable) that follows when its value changes from HIGH to LOW or vice-versa (otherwise, every time the value of one of the pokes is changed, every poke sends an event). The logic inside a TimestampPoke node is shown in Figure \ref{fig:timestamp_poke}.

% \begin{figure}[!ht]
%     \centering
%     \includegraphics[width=0.6\textwidth]{Figures/filter_poke_events.png}
%     \caption{FilterPokeEvents GroupWorkflow}
%     \label{fig:filter_poke_events}
% \end{figure}

% The FilterPokeEvents node starts by separating the Value and Seconds components of the input. The BitwiseAnd node only lets the values corresponding to the select port pass through. Then the ExpressionTransform node converts the values from byte to boolean and the WithLatestFrom node reunites the two branches. The CreateTimestamped node converts the tuple into a Bonsai.Harp.Timestamped type